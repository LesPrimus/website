{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This is my website about coding and Python.</p> <p>The key contents are:</p> <ul> <li>Posts: A series of posts or coding snippets about Python.</li> </ul>"},{"location":"Gaming/elden-ring/","title":"Elden-Ring","text":""},{"location":"Gaming/elden-ring/#class-vagabond","title":"Class: Vagabond","text":""},{"location":"Gaming/elden-ring/#level-400","title":"Level: 400","text":""},{"location":"Gaming/elden-ring/#build-strarc","title":"Build: Str/Arc","text":""},{"location":"Gaming/elden-ring/#sword","title":"Sword","text":""},{"location":"Gaming/lords-of-the-fallen/","title":"Lords of the Fallen.","text":""},{"location":"music/my-basses/","title":"My current basses.","text":"<p>I am a huge fan of Yamaha basses, in particular the first 6 strings series like:</p>"},{"location":"music/my-basses/#yamaha-trb6-p-with-piezo-at-the-bridge","title":"YAMAHA TRB6-P with piezo at the bridge.","text":""},{"location":"music/my-basses/#yamaha-trb6-jp-john-patitucci-signature","title":"YAMAHA TRB6-JP John Patitucci signature.","text":""},{"location":"music/strings-set/","title":"Custom String set.","text":"<p>I use a very light custom set (.028 -.030 -.050 - .070 - .090 - .110)</p>"},{"location":"music/strings-set/#c-string-daddario-xlb028w-single-bass-string","title":"C-String: D'Addario XLB028W Single Bass String","text":""},{"location":"music/strings-set/#b-string-rotosound-sbl-110-single-bass-string","title":"B-String: Rotosound SBL 110 Single Bass String","text":""},{"location":"music/strings-set/#in-between-warwick-red-bass-el-030-090","title":"In-Between: Warwick RED Bass EL .030-.090","text":""},{"location":"python/asyncio-queue-poison-pills/","title":"Asyncio Queue poison pills.","text":"<p>In an asyncio setup like this:</p> <pre><code>import asyncio\nimport random\nasync def worker(name, queue: asyncio.Queue):\nwhile True:\nsleep_for = await queue.get()\nawait asyncio.sleep(sleep_for)\nqueue.task_done()\nprint(f'worker - {name} has slept for {sleep_for:.2f} seconds')\nasync def main():\nnr_worker = 3\nqueue = asyncio.Queue()\nfor _ in range(20):\nsleep_for = random.uniform(0.05, 1.0)\nqueue.put_nowait(sleep_for)\nasync with asyncio.TaskGroup() as tg:\nfor idx in range(nr_worker):\ntg.create_task(worker(idx, queue))\nasyncio.run(main())\n</code></pre> <p>The main process block forever.</p> <p>But if we put some poisoning pills one for every worker, like this:</p> <pre><code>import asyncio\nimport random\n_poison_pill = object()\nasync def worker(name, queue: asyncio.Queue):\nwhile True:\nsleep_for = await queue.get()\n# break if we are poisoned.\nif sleep_for is _poison_pill:\nbreak\nawait asyncio.sleep(sleep_for)\nqueue.task_done()\nprint(f'worker - {name} has slept for {sleep_for:.2f} seconds')\nasync def main():\nnr_worker = 3\nqueue = asyncio.Queue()\nfor _ in range(20):\nsleep_for = random.uniform(0.05, 1.0)\nqueue.put_nowait(sleep_for)\n# Put some pills into the queue for every worker.:\nfor _ in range(nr_worker):\nqueue.put_nowait(_poison_pill)\nasync with asyncio.TaskGroup() as tg:\nfor idx in range(nr_worker):\ntg.create_task(worker(idx, queue))\nasyncio.run(main())\n</code></pre> <p>Not blocking anymore.</p>"},{"location":"python/context-manager-iterator/","title":"Context Manager with iterator.","text":"<p>Somewhere in the web I found (cannot remember where!!) a nice pattern that combine an Iterator with a context-manager.</p> <pre><code>class RetryError(Exception):\npass\nclass SwallowException:\ndef __init__(self, notify_success, max_retry):\nself._notify_success = notify_success\nself._max_retry = max_retry\ndef __enter__(self):\nreturn self\ndef __exit__(self, exc_type, exc_val, exc_tb):\nif exc_val:\nprint(f\"Got an exception: {exc_type} - {exc_val if exc_val else ''}\")\nelse:\nself._notify_success()\nreturn True\nclass Retry:\ndef __init__(self, max_retry):\nself._max_retry = max_retry\nself._success = False\ndef __iter__(self):\nfor i in range(self._max_retry):\nyield SwallowException(self.succeed, i)\nif self._success is True:\nprint(\"Finished success..\")\nbreak\nelse:\nraise RetryError(\"too many attempts\")\ndef succeed(self):\nself._success = True\nfor attempt in Retry(3):\nwith attempt:\n1 / 0\n</code></pre> <p>This combine an iterator that yield a context manager. The context manager catch all exceptions and if no exceptions are thrown, notify the Iterator.</p>"},{"location":"python/decorator-descriptor/","title":"Decorator descriptor","text":"<p>A simple use case of a decorator with get method, turned into a non data-descriptor.</p> <pre><code>class MyDeco:\ndef __init__(self, func):\nself.func = func\ndef __get__(self, instance, parent):\nfunc = functools.partial(self.__call__, instance)\nreturn functools.update_wrapper(func, self.func)\ndef __call__(self, *args, **kwargs):\nresult = self.func(*args, **kwargs)\nreturn result\n</code></pre> <p>usage:</p> <pre><code>@MyDeco\ndef hello(\"name\"):\nreturn f\"Hello {name}\"\nclass Person:\n@MyDeco\ndef hello(self, name):\nreturn f\"Hello {name}\"\n</code></pre>"},{"location":"python/fastapi-sqlalchemy-async/","title":"FastApi SqlAlchemy Async Orm","text":"<p>Inside a virtualenv install:</p> <p>FastApi <pre><code>pip install \"fastapi[all]\"\n</code></pre></p> <p>SqlAlchemy: <pre><code>pip install sqlalchemy\n</code></pre></p> <p>Alembic: <pre><code>pip install alembic\n</code></pre></p> <p>AsyncPg <pre><code>pip install asyncpg\n</code></pre></p> <p>Create the database models.</p> db/models.py<pre><code>from typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\nclass Base(DeclarativeBase):\npass\nclass User(Base):\n__tablename__ = \"user_account\"\nid: Mapped[int] = mapped_column(primary_key=True)\nname: Mapped[str] = mapped_column(String(30))\nfullname: Mapped[Optional[str]]\naddresses: Mapped[List[\"Address\"]] = relationship(\nback_populates=\"user\", cascade=\"all, delete-orphan\"\n)\ndef __repr__(self) -&gt; str:\nreturn f\"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})\"\nclass Address(Base):\n__tablename__ = \"address\"\nid: Mapped[int] = mapped_column(primary_key=True)\nemail_address: Mapped[str]\nuser_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\nuser: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\ndef __repr__(self) -&gt; str:\nreturn f\"Address(id={self.id!r}, email_address={self.email_address!r})\"\n</code></pre> <p>Configure the db session</p> db/main.py<pre><code>from sqlmodel.ext.asyncio import (\ncreate_async_engine, \nAsyncSession, \nAsyncEngine,\nasync_sessionmaker\n)\nDATABASE_URL = \"postgresql+asyncpg://postgres:postgres@localhost:5432/db_name\"\nengine = create_async_engine(\nDATABASE_URL,\necho=True,\n)\nasync def get_session() -&gt; AsyncSession:\nasync_session = async_sessionmaker(\nengine, expire_on_commit=False\n)\nasync with async_session() as session:\nyield session\n</code></pre> <p>Now we can use the session as dependency injection.</p> <pre><code>@app.get(\"/users\")\nasync def get_users(session: Annotated[AsyncSession, Depends(get_session)]):\nstmt = select(User)\nresults = await session.execute(stmt)\nprint(results.scalars())\nreturn {\"Hello\": \"World\"}\n</code></pre> <p>Alembic configurations:</p> <p>In a console run: <pre><code>alembic init -t async migrations\n</code></pre> then configure env.py</p> <p>migrations/env.py<pre><code>target_metadata = Base.metadata\n# set database url outside alembic.ini\nconfig.set_main_option('sqlalchemy.url', DATABASE_URL)\n</code></pre> In the console run:</p> <pre><code>alembic revision --autogenerate -m \"init\"\n</code></pre> <p>And apply the migration:</p> <pre><code>alembic upgrade head\n</code></pre>"},{"location":"python/postgres-advisory-lock/","title":"Postgres advisory lock.","text":"<p>A typical deadlock in a Django app.</p> <pre><code>def test_deadlock_without_transaction_advisory_lock(transactional_db):\nimport threading\nfrom django.db import transaction\nfrom myapp.models import Book\nlock_id = \"foo.bar\"\nbook1 = Book.objects.create(name=\"Book-1\")\nbook2 = Book.objects.create(name=\"Book-2\")\ncaught = None\nevent = threading.Event()\ndef update_1(e, _lock_id):\nnonlocal caught\ntry:\nwith transaction.atomic():\ne.wait()\nBook.objects.filter(id=book1.pk).update(name=\"Name-1\")\nBook.objects.filter(id=book2.pk).update(name=\"Name-2\")\nexcept Exception as exc:\ncaught = exc\ndef update_2(e, _lock_id):\nnonlocal caught\ntry:\nwith transaction.atomic():\ne.wait()\nBook.objects.filter(id=book2.pk).update(name=\"Name3\")\nBook.objects.filter(id=book1.pk).update(name=\"Name4\")\nexcept Exception as exc:\ncaught = exc\nthread_a = threading.Thread(target=update_1, args=(event, lock_id))\nthread_a.start()\nthread_b = threading.Thread(target=update_2, args=(event, lock_id))\nthread_b.start()\nevent.set()\nthread_a.join()\nthread_b.join()\nassert caught is not None\n</code></pre> <p>Avoid a deadlock with an advisory lock.</p> <pre><code>from enum import Enum\nimport contextlib\nimport zlib\nfrom typing import Optional, Callable\nclass LockQuery(Enum):\nTRANSACTION_ADVISORY_LOCK_BASE = \"SELECT pg_advisory_xact_lock({lock_id})\"\nTRANSACTION_ADVISORY_LOCK_TUPLE_FORMAT = (\n\"SELECT pg_advisory_xact_lock({lock_id_1}, {lock_id_2})\"\n)\ndef generate_crc_32_lock_id(lock_id: str) -&gt; int:\nreturn zlib.crc32(lock_id.encode(\"utf-8\"))\n@contextlib.contextmanager\ndef transaction_advisory_lock(\nlock_id: str,\nusing: Optional[str] = None,\nkey_generator: Optional[Callable[[str], int]] = generate_crc_32_lock_id,\n):\n\"\"\"\n    Obtains an exclusive transaction-level advisory lock.\n    \"\"\"\nusing = using or DEFAULT_DB_ALIAS\nlock_id = key_generator(lock_id)\nmatch lock_id:\ncase int():\nquery = LockQuery.TRANSACTION_ADVISORY_LOCK_BASE.value\ncommand = query.format(lock_id=lock_id)\ncase [int() as l1, int() as l2]:\nquery = LockQuery.TRANSACTION_ADVISORY_LOCK_TUPLE_FORMAT.value\ncommand = query.format(lock_id_1=l1, lock_id_2=l2)\ncase _:\nraise ValueError(\"Unsupported param format.\")\nconnection = connections[using]\nif not connection.in_atomic_block:\nraise RuntimeError(\"Must be inside a transaction.\")\ncursor = connection.cursor()\ncursor.execute(command)\ntry:\nyield\nfinally:\ncursor.close()\n</code></pre>"},{"location":"python/python-web-sockets-pub-sub/","title":"Python Websockets pub-sub","text":"index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;WebSocket chat&lt;/h1&gt;\n&lt;form action=\"\" onsubmit=\"sendMessage(event)\"&gt;\n&lt;input type=\"text\" id=\"messageText\" autocomplete=\"off\"/&gt;\n&lt;button&gt;Send&lt;/button&gt;\n&lt;/form&gt;\n&lt;ul id=\"messages\"&gt;\n&lt;/ul&gt;\n&lt;script src=\"scripts/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> main.js<pre><code>let ws = new WebSocket(\"ws://localhost:1234\")\nws.onmessage = function (event) {\nlet messages = document.getElementById(\"messages\");\nlet message = document.createElement('li');\nlet content = document.createTextNode(event.data);\nmessage.appendChild(content);\nmessages.appendChild(message);\n}\nfunction sendMessage(event) {\nlet input = document.getElementById(\"messageText\");\nws.send(input.value);\ninput.value = \"\";\nevent.preventDefault();\n}\n</code></pre> ws_server.py<pre><code>import asyncio\nfrom functools import partial\nfrom websockets import serve\nfrom websockets.legacy.server import WebSocketServerProtocol\nclass PubSub:\ndef __init__(self):\nself.waiter = asyncio.Future()\nasync def publish(self, value):\nwaiter, self.waiter = self.waiter, asyncio.Future()\nwaiter.set_result((value, self.waiter))\nasync def subscribe(self):\nwaiter = self.waiter\nwhile True:\nvalue, waiter = await waiter\nyield value\n__aiter__ = subscribe\nasync def check_message(websocket: WebSocketServerProtocol, pub_sub: PubSub):\nasync for message in pub_sub:\nawait websocket.send(message)\nasync def handler(websocket: WebSocketServerProtocol, pub_sub: PubSub):\nprint(f\"Got a connection from {websocket.remote_address}\")\ntask = asyncio.create_task(check_message(websocket, pub_sub))\ntry:\nwhile True:\nmessage = await websocket.recv()\nawait pub_sub.publish(message)\nfinally:\ntask.cancel()\nasync def main():\npub_sub = PubSub()\nasync with serve(partial(handler, pub_sub=pub_sub), \"localhost\", 1234):\nawait asyncio.Future()\nif __name__ == '__main__':\nasyncio.run(main(), debug=True)\n</code></pre>"}]}